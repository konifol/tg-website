{% extends "base.html" %}

{% block title %}Создать бота - Bot Creator Platform{% endblock %}

{% block content %}
<style>
.drop-zone {
    min-height: 200px;
    border: 2px dashed #dee2e6;
    border-radius: 8px;
    transition: all 0.3s ease;
    background: #f8f9fa;
}

.drop-zone.drag-over {
    border-color: #007bff;
    background: #e3f2fd;
    transform: scale(1.02);
}

.block-type {
    cursor: grab;
    transition: all 0.2s ease;
}

.block-type:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.1);
}

.block-type:active {
    cursor: grabbing;
}

.block-config {
    background: #f8f9fa;
    border-radius: 6px;
    padding: 15px;
    margin-top: 10px;
}

.field-group {
    margin-bottom: 15px;
}

.field-group label {
    font-weight: 600;
    color: #495057;
    margin-bottom: 5px;
}

.field-group input,
.field-group textarea,
.field-group select {
    border: 1px solid #ced4da;
    border-radius: 4px;
    transition: border-color 0.2s ease;
}

.field-group input:focus,
.field-group textarea:focus,
.field-group select:focus {
    border-color: #007bff;
    box-shadow: 0 0 0 0.2rem rgba(0,123,255,0.25);
}

.required-field::after {
    content: " *";
    color: #dc3545;
}

.block-actions {
    display: flex;
    gap: 10px;
    margin-top: 15px;
}

.block-actions button {
    flex: 1;
}

.block-info {
    background: #e9ecef;
    border-radius: 4px;
    padding: 10px;
    margin-bottom: 15px;
    font-size: 0.9em;
    color: #6c757d;
}

.block-info i {
    margin-right: 5px;
}

.json-validation-feedback {
    font-size: 0.875em;
    padding: 0.25rem 0.5rem;
    border-radius: 0.25rem;
    background-color: #f8f9fa;
    border: 1px solid #dee2e6;
}

.json-validation-feedback.text-success {
    background-color: #d1e7dd;
    border-color: #badbcc;
    color: #0f5132;
}

.json-validation-feedback.text-danger {
    background-color: #f8d7da;
    border-color: #f5c2c7;
    color: #842029;
}

.json-input:focus {
    border-color: #007bff;
    box-shadow: 0 0 0 0.2rem rgba(0,123,255,0.25);
}

.json-input.error {
    border-color: #dc3545;
    box-shadow: 0 0 0 0.2rem rgba(220,53,69,0.25);
}

.json-input.valid {
    border-color: #198754;
    box-shadow: 0 0 0 0.2rem rgba(25,135,84,0.25);
}

.button-preview {
    background-color: #f8f9fa;
    border: 1px solid #dee2e6;
    border-radius: 0.375rem;
    padding: 1rem;
}

.button-preview h6 {
    color: #495057;
    margin-bottom: 0.75rem;
    font-size: 0.875rem;
    font-weight: 600;
}

.button-preview .btn-group-vertical {
    gap: 0.25rem;
}

.button-preview .btn-group {
    gap: 0.25rem;
}

.button-preview .btn {
    font-size: 0.75rem;
    padding: 0.25rem 0.5rem;
    border-radius: 0.25rem;
    min-width: 60px;
}

.button-preview .btn-outline-primary {
    color: #0d6efd;
    border-color: #0d6efd;
}

.button-preview .btn-outline-primary:hover {
    background-color: #0d6efd;
    color: white;
}

.button-preview .btn-outline-secondary {
    color: #6c757d;
    border-color: #6c757d;
}

.button-preview .btn-outline-secondary:hover {
    background-color: #6c757d;
    color: white;
}
</style>
>>>>>>> main
<div class="container-fluid mt-4">
    <div class="row">
        <!-- Left Panel - Bot Configuration -->
        <div class="col-lg-8">
            <div class="card border-0 shadow-sm">
                <div class="card-header bg-primary text-white">
                    <h5 class="mb-0">
                        <i class="fas fa-robot me-2"></i>Создание Telegram бота
                    </h5>
                </div>
                <div class="card-body">
                    <form id="botForm">
                        <div class="row mb-3">
                            <div class="col-md-6">
                                <label for="botName" class="form-label">Название бота</label>
                                <input type="text" class="form-control" id="botName" name="botName" required>
                            </div>
                            <div class="col-md-6">
                                <label for="botToken" class="form-label">Токен бота</label>
                                <input type="text" class="form-control" id="botToken" name="botToken" 
                                       placeholder="123456789:ABCdefGHIjklMNOpqrsTUVwxyz" required>
                                <div class="form-text">
                                    <a href="https://t.me/BotFather" target="_blank" class="text-decoration-none">
                                        <i class="fas fa-external-link-alt me-1"></i>Получить токен у @BotFather
                                    </a>
                                </div>
                            </div>
                        </div>
                        
                        <div class="mb-3">
                            <label for="botDescription" class="form-label">Описание бота</label>
                            <textarea class="form-control" id="botDescription" name="botDescription" rows="3" 
                                      placeholder="Опишите, что делает ваш бот..."></textarea>
                        </div>
                    </form>
                </div>
            </div>

            <!-- Bot Blocks Configuration -->
            <div class="card border-0 shadow-sm mt-4">
                <div class="card-header bg-success text-white">
                    <h5 class="mb-0">
                        <i class="fas fa-puzzle-piece me-2"></i>Конфигурация блоков
                    </h5>
                </div>
                <div class="card-body">
<<<<<<< HEAD
                    <div id="botBlocks" class="drop-zone" 
                         ondrop="handleDrop(event)" 
                         ondragover="handleDragOver(event)"
                         ondragenter="handleDragEnter(event)"
                         ondragleave="handleDragLeave(event)">
=======
                    <div id="botBlocks">
>>>>>>> main
                        <!-- Blocks will be added here -->
                    </div>
                    
                    <div class="text-center mt-3">
                        <button type="button" class="btn btn-outline-success" onclick="addBlock()">
                            <i class="fas fa-plus me-2"></i>Добавить блок
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Right Panel - Block Library -->
        <div class="col-lg-4">
            <div class="card border-0 shadow-sm">
                <div class="card-header bg-info text-white">
                    <h5 class="mb-0">
                        <i class="fas fa-cube me-2"></i>Библиотека блоков
                    </h5>
                </div>
                <div class="card-body">
                    <div class="mb-3">
                        <input type="text" class="form-control" id="blockSearch" 
                               placeholder="Поиск блоков...">
                    </div>
                    
                    <div id="blockLibrary">
                        <!-- Block types will be listed here -->
                    </div>
                </div>
            </div>

            <!-- Actions Panel -->
            <div class="card border-0 shadow-sm mt-4">
                <div class="card-header bg-warning text-dark">
                    <h5 class="mb-0">
                        <i class="fas fa-cogs me-2"></i>Действия
                    </h5>
                </div>
                <div class="card-body">
                    <div class="d-grid gap-2">
                        <button type="button" class="btn btn-primary btn-lg" onclick="generateCode()">
                            <i class="fas fa-code me-2"></i>Сгенерировать код
                        </button>
                        <button type="button" class="btn btn-success btn-lg" onclick="saveBot()">
                            <i class="fas fa-save me-2"></i>Сохранить бота
                        </button>
                        <button type="button" class="btn btn-outline-secondary" onclick="clearSession()">
                            <i class="fas fa-trash me-2"></i>Очистить сессию
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Generated Code Modal -->
<div class="modal fade" id="codeModal" tabindex="-1" aria-labelledby="codeModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-xl">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="codeModalLabel">
                    <i class="fas fa-code me-2"></i>Сгенерированный Python код
                </h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <div class="mb-3">
                    <button class="btn btn-outline-primary btn-sm" onclick="copyCode()">
                        <i class="fas fa-copy me-1"></i>Копировать код
                    </button>
                    <button class="btn btn-outline-success btn-sm" onclick="downloadCode()">
                        <i class="fas fa-download me-1"></i>Скачать файл
                    </button>
                </div>
                <pre><code id="generatedCode" class="language-python"></code></pre>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Закрыть</button>
            </div>
        </div>
    </div>
</div>

<script>
<<<<<<< HEAD
// Block types available with descriptions and fields
=======
// Block types available
>>>>>>> main
const blockTypes = [
    {
        id: 'welcome',
        name: 'Приветствие',
<<<<<<< HEAD
        description: 'Команда /start - отправляет приветственное сообщение при запуске бота',
        icon: 'fas fa-hand-wave',
        color: 'primary',
        fields: [
            {name: 'message', type: 'textarea', label: 'Приветственное сообщение', required: true}
        ]
=======
        description: 'Команда /start',
        icon: 'fas fa-hand-wave',
        color: 'primary'
>>>>>>> main
    },
    {
        id: 'help',
        name: 'Помощь',
<<<<<<< HEAD
        description: 'Команда /help - показывает список доступных команд',
        icon: 'fas fa-question-circle',
        color: 'success',
        fields: [
            {name: 'commands', type: 'textarea', label: 'Список команд', required: true}
        ]
=======
        description: 'Команда /help',
        icon: 'fas fa-question-circle',
        color: 'success'
>>>>>>> main
    },
    {
        id: 'about',
        name: 'О боте',
<<<<<<< HEAD
        description: 'Команда /about - информация о боте и его возможностях',
        icon: 'fas fa-info-circle',
        color: 'info',
        fields: [
            {name: 'description', type: 'textarea', label: 'Описание бота', required: true}
        ]
    },
    {
        id: 'message',
        name: 'Сообщение',
        description: 'Отправляет текстовое сообщение пользователю',
        icon: 'fas fa-comment',
        color: 'primary',
        fields: [
            {name: 'text', type: 'textarea', label: 'Текст сообщения', required: true}
        ]
    },
    {
        id: 'photo',
        name: 'Фото',
        description: 'Отправляет изображение с подписью',
        icon: 'fas fa-image',
        color: 'success',
        fields: [
            {name: 'photo_url', type: 'url', label: 'URL изображения', required: true},
            {name: 'caption', type: 'textarea', label: 'Подпись к фото', required: false}
        ]
    },
    {
        id: 'inline_keyboard',
        name: 'Инлайн кнопки',
        description: 'Создает интерактивные кнопки под сообщением',
        icon: 'fas fa-keyboard',
        color: 'warning',
        fields: [
            {name: 'buttons', type: 'json', label: 'JSON структура кнопок', required: true},
            {name: 'text', type: 'textarea', label: 'Текст сообщения с кнопками', required: true}
        ]
    },
    {
        id: 'reply_keyboard',
        name: 'Клавиатура',
        description: 'Создает постоянную клавиатуру для пользователя',
        icon: 'fas fa-keyboard',
        color: 'secondary',
        fields: [
            {name: 'buttons', type: 'json', label: 'JSON структура кнопок', required: true},
            {name: 'resize', type: 'checkbox', label: 'Автоматически изменять размер', required: false},
            {name: 'one_time', type: 'checkbox', label: 'Одноразовая клавиатура', required: false}
        ]
    },
    {
        id: 'condition',
        name: 'Условие',
        description: 'Выполняет действия в зависимости от условия',
        icon: 'fas fa-code-branch',
        color: 'dark',
        fields: [
            {name: 'condition', type: 'text', label: 'Условие (Python код)', required: true},
            {name: 'true_action', type: 'text', label: 'Действие если True', required: true},
            {name: 'false_action', type: 'text', label: 'Действие если False', required: false}
        ]
    },
    {
        id: 'loop',
        name: 'Цикл',
        description: 'Повторяет действия заданное количество раз',
        icon: 'fas fa-redo',
        color: 'info',
        fields: [
            {name: 'iterations', type: 'number', label: 'Количество повторений', required: true},
            {name: 'action', type: 'text', label: 'Действие для повторения', required: true}
        ]
=======
        description: 'Команда /about',
        icon: 'fas fa-info-circle',
        color: 'info'
>>>>>>> main
    },
    {
        id: 'custom',
        name: 'Кастомный ответ',
        description: 'Ответ на ключевые слова',
        icon: 'fas fa-comments',
<<<<<<< HEAD
        color: 'warning',
        fields: [
            {name: 'keywords', type: 'text', label: 'Ключевые слова', required: true},
            {name: 'response', type: 'text', label: 'Ответ', required: true}
        ]
=======
        color: 'warning'
>>>>>>> main
    },
    {
        id: 'echo',
        name: 'Эхо',
        description: 'Повторение всех сообщений',
        icon: 'fas fa-echo',
<<<<<<< HEAD
        color: 'secondary',
        fields: [
            {name: 'prefix', type: 'text', label: 'Префикс для эхо', required: false}
        ]
=======
        color: 'secondary'
>>>>>>> main
    }
];

let botBlocks = [];
let blockCounter = 0;

// Initialize button previews for existing blocks
function initializeButtonPreviews() {
    const jsonInputs = document.querySelectorAll('.json-input');
    jsonInputs.forEach(input => {
        const blockType = input.closest('.block-config').querySelector('.block-info strong').textContent;
        if (blockType.includes('Инлайн кнопки') || blockType.includes('Клавиатура')) {
            const blockTypeId = blockType.includes('Инлайн кнопки') ? 'inline_keyboard' : 'reply_keyboard';
            previewButtons(input, blockTypeId);
        }
    });
}

// Initialize page
document.addEventListener('DOMContentLoaded', function() {
    loadSession();
    renderBlockLibrary();
    renderBlocks();
<<<<<<< HEAD
    
    // Add search functionality
    document.getElementById('blockSearch').addEventListener('input', function() {
        filterBlocks(this.value);
    });
});

// Filter blocks by search
function filterBlocks(searchTerm) {
    const library = document.getElementById('blockLibrary');
    const filteredBlocks = blockTypes.filter(block => 
        block.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
        block.description.toLowerCase().includes(searchTerm.toLowerCase())
    );
    
    library.innerHTML = filteredBlocks.map(block => `
        <div class="card mb-2 border-0 shadow-sm block-type" 
             data-block-type="${block.id}" 
             draggable="true">
            <div class="card-body p-3">
                <div class="d-flex align-items-center">
                    <div class="bg-${block.color} bg-gradient text-white rounded-circle d-flex align-items-center justify-content-center me-3" 
                         style="width: 40px; height: 40px;">
                        <i class="${block.icon}"></i>
                    </div>
                    <div>
                        <h6 class="mb-1">${block.name}</h6>
                        <small class="text-muted">${block.description}</small>
                    </div>
                </div>
            </div>
        </div>
    `).join('');
    
    // Re-add drag functionality
    document.querySelectorAll('.block-type').forEach(block => {
        block.addEventListener('dragstart', handleDragStart);
    });
}

=======
});

>>>>>>> main
// Render block library
function renderBlockLibrary() {
    const library = document.getElementById('blockLibrary');
    library.innerHTML = blockTypes.map(block => `
        <div class="card mb-2 border-0 shadow-sm block-type" 
             data-block-type="${block.id}" 
             draggable="true">
            <div class="card-body p-3">
                <div class="d-flex align-items-center">
                    <div class="bg-${block.color} bg-gradient text-white rounded-circle d-flex align-items-center justify-content-center me-3" 
                         style="width: 40px; height: 40px;">
                        <i class="${block.icon}"></i>
                    </div>
                    <div>
                        <h6 class="mb-1">${block.name}</h6>
                        <small class="text-muted">${block.description}</small>
                    </div>
                </div>
            </div>
        </div>
    `).join('');
    
    // Add drag and drop functionality
    document.querySelectorAll('.block-type').forEach(block => {
        block.addEventListener('dragstart', handleDragStart);
    });
}

// Render current blocks
function renderBlocks() {
    const container = document.getElementById('botBlocks');
    if (botBlocks.length === 0) {
        container.innerHTML = `
            <div class="text-center py-5 text-muted">
                <i class="fas fa-puzzle-piece fa-3x mb-3"></i>
                <h5>Нет добавленных блоков</h5>
                <p>Перетащите блоки из библиотеки или нажмите "Добавить блок"</p>
            </div>
        `;
        return;
    }
    
    container.innerHTML = botBlocks.map((block, index) => `
        <div class="card mb-3 border-0 shadow-sm" data-block-index="${index}">
            <div class="card-header bg-${block.color} text-white d-flex justify-content-between align-items-center">
                <h6 class="mb-0">
                    <i class="${block.icon} me-2"></i>${block.name}
                </h6>
<<<<<<< HEAD
                <span class="badge bg-light text-dark">${index + 1}</span>
=======
                <button type="button" class="btn btn-sm btn-outline-light" onclick="removeBlock(${index})">
                    <i class="fas fa-times"></i>
                </button>
>>>>>>> main
            </div>
            <div class="card-body">
                ${renderBlockConfig(block, index)}
            </div>
        </div>
    `).join('');
}

<<<<<<< HEAD
// Render block configuration with dynamic fields
function renderBlockConfig(block, index) {
    const blockType = blockTypes.find(bt => bt.id === block.type);
    if (!blockType) return '<p class="text-muted">Конфигурация недоступна</p>';
    
    let configHtml = `
        <div class="block-info">
            <i class="fas fa-info-circle"></i>
            <strong>${blockType.name}:</strong> ${blockType.description}
        </div>
        <div class="block-config">
    `;
    
    if (blockType.fields) {
        blockType.fields.forEach(field => {
            const fieldValue = block.config[field.name] || '';
            const requiredClass = field.required ? 'required-field' : '';
            
            switch (field.type) {
                case 'textarea':
                    configHtml += `
                        <div class="field-group">
                            <label class="form-label ${requiredClass}">${field.label}</label>
                            <textarea class="form-control" rows="3" 
                                      onchange="updateBlockConfig(${index}, '${field.name}', this.value)"
                                      placeholder="${field.label}">${fieldValue}</textarea>
                        </div>
                    `;
                    break;
                case 'text':
                    configHtml += `
                        <div class="field-group">
                            <label class="form-label ${requiredClass}">${field.label}</label>
                            <input type="text" class="form-control" 
                                   onchange="updateBlockConfig(${index}, '${field.name}', this.value)"
                                   placeholder="${field.label}" 
                                   value="${fieldValue}">
                        </div>
                    `;
                    break;
                case 'url':
                    configHtml += `
                        <div class="field-group">
                            <label class="form-label ${requiredClass}">${field.label}</label>
                            <input type="url" class="form-control" 
                                   onchange="updateBlockConfig(${index}, '${field.name}', this.value)"
                                   placeholder="https://example.com/image.jpg" 
                                   value="${fieldValue}">
                        </div>
                    `;
                    break;
                case 'number':
                    configHtml += `
                        <div class="field-group">
                            <label class="form-label ${requiredClass}">${field.label}</label>
                            <input type="number" class="form-control" 
                                   onchange="updateBlockConfig(${index}, '${field.name}', this.value)"
                                   placeholder="1" 
                                   value="${fieldValue}">
                        </div>
                    `;
                    break;
                case 'json':
                    let placeholder = '';
                    let helpText = '';
                    
                    if (field.name === 'buttons') {
                        if (block.type === 'inline_keyboard') {
                            placeholder = '[["Кнопка 1", "Кнопка 2"], ["Кнопка 3"]]';
                            helpText = 'Формат: массив массивов. Каждый внутренний массив - это ряд кнопок. Пример: [["Да", "Нет"], ["Отмена"]]';
                        } else if (block.type === 'reply_keyboard') {
                            placeholder = '[["Кнопка 1", "Кнопка 2"], ["Кнопка 3", "Кнопка 4"]]';
                            helpText = 'Формат: массив массивов. Каждый внутренний массив - это ряд кнопок. Пример: [["Да", "Нет"], ["Отмена"]]';
                        } else {
                            placeholder = '[["Кнопка 1"], ["Кнопка 2"]]';
                            helpText = 'Введите JSON структуру кнопок';
                        }
                    } else {
                        placeholder = '[["Кнопка 1"], ["Кнопка 2"]]';
                        helpText = 'Введите JSON структуру кнопок';
                    }
                    
                    configHtml += `
                        <div class="field-group">
                            <label class="form-label ${requiredClass}">${field.label}</label>
                            <textarea class="form-control json-input" rows="4" 
                                      onchange="updateBlockConfig(${index}, '${field.name}', this.value); previewButtons(this, '${block.type}')"
                                      onblur="validateJSON(this, ${index}, '${field.name}')"
                                      placeholder="${placeholder}">${fieldValue}</textarea>
                            <small class="form-text text-muted">
                                <i class="fas fa-code"></i> ${helpText}
                            </small>
                            <div class="json-validation-feedback mt-1" style="display: none;"></div>
                            ${field.name === 'buttons' ? `<div class="button-preview mt-2" style="display: none;"></div>` : ''}
                        </div>
                    `;
                    break;
                case 'checkbox':
                    configHtml += `
                        <div class="field-group">
                            <div class="form-check">
                                <input type="checkbox" class="form-check-input" 
                                       onchange="updateBlockConfig(${index}, '${field.name}', this.checked)"
                                       ${fieldValue ? 'checked' : ''}>
                                <label class="form-check-label">${field.label}</label>
                            </div>
                        </div>
                    `;
                    break;
                default:
                    configHtml += `
                        <div class="field-group">
                            <label class="form-label ${requiredClass}">${field.label}</label>
                            <input type="text" class="form-control" 
                                   onchange="updateBlockConfig(${index}, '${field.name}', this.value)"
                                   placeholder="${field.label}" 
                                   value="${fieldValue}">
                        </div>
                    `;
            }
        });
    }
    
    configHtml += `
        </div>
        <div class="block-actions">
            <button type="button" class="btn btn-outline-secondary btn-sm" onclick="moveBlockUp(${index})" ${index === 0 ? 'disabled' : ''}>
                <i class="fas fa-arrow-up"></i> Вверх
            </button>
            <button type="button" class="btn btn-outline-secondary btn-sm" onclick="moveBlockDown(${index})" ${index === botBlocks.length - 1 ? 'disabled' : ''}>
                <i class="fas fa-arrow-down"></i> Вниз
            </button>
            <button type="button" class="btn btn-outline-danger btn-sm" onclick="removeBlock(${index})">
                <i class="fas fa-trash"></i> Удалить
            </button>
        </div>
    `;
    
    return configHtml;
=======
// Render block configuration
function renderBlockConfig(block, index) {
    switch (block.type) {
        case 'welcome':
            return `
                <div class="mb-3">
                    <label class="form-label">Приветственное сообщение</label>
                    <textarea class="form-control" rows="3" 
                              onchange="updateBlockConfig(${index}, 'message', this.value)"
                              placeholder="Введите приветственное сообщение...">${block.config.message || ''}</textarea>
                </div>
            `;
        case 'help':
            return `
                <div class="mb-3">
                    <label class="form-label">Список команд</label>
                    <textarea class="form-control" rows="3" 
                              onchange="updateBlockConfig(${index}, 'commands', this.value)"
                              placeholder="Введите список команд...">${block.config.commands || ''}</textarea>
                </div>
            `;
        case 'about':
            return `
                <div class="mb-3">
                    <label class="form-label">Описание бота</label>
                    <textarea class="form-control" rows="3" 
                              onchange="updateBlockConfig(${index}, 'description', this.value)"
                              placeholder="Введите описание бота...">${block.config.description || ''}</textarea>
                </div>
            `;
        case 'custom':
            return `
                <div class="row">
                    <div class="col-md-6">
                        <label class="form-label">Ключевые слова</label>
                        <input type="text" class="form-control" 
                               onchange="updateBlockConfig(${index}, 'keywords', this.value)"
                               placeholder="слово1, слово2, слово3" 
                               value="${block.config.keywords || ''}">
                    </div>
                    <div class="col-md-6">
                        <label class="form-label">Ответ</label>
                        <input type="text" class="form-control" 
                               onchange="updateBlockConfig(${index}, 'response', this.value)"
                               placeholder="Ответ на ключевые слова" 
                               value="${block.config.response || ''}">
                    </div>
                </div>
            `;
        case 'echo':
            return `
                <div class="mb-3">
                    <label class="form-label">Префикс для эхо</label>
                    <input type="text" class="form-control" 
                           onchange="updateBlockConfig(${index}, 'prefix', this.value)"
                           placeholder="Эхо: " 
                           value="${block.config.prefix || ''}">
                </div>
            `;
        default:
            return '<p class="text-muted">Конфигурация недоступна</p>';
    }
}

// Add new block
function addBlock() {
    const blockType = blockTypes[0]; // Default to welcome block
    addBlockByType(blockType.id);
}

// Add block by type
function addBlockByType(blockTypeId) {
    const blockType = blockTypes.find(bt => bt.id === blockTypeId);
    if (blockType) {
        const newBlock = {
            id: blockCounter++,
            type: blockType.id,
            name: blockType.name,
            icon: blockType.icon,
            color: blockType.color,
            config: {}
        };
        
        botBlocks.push(newBlock);
        renderBlocks();
        saveSession();
        
        // Scroll to the new block
        setTimeout(() => {
            const newBlockElement = document.querySelector(`[data-block-index="${botBlocks.length - 1}"]`);
            if (newBlockElement) {
                newBlockElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        }, 100);
    }
}

// Remove block
function removeBlock(index) {
    if (confirm('Вы уверены, что хотите удалить этот блок?')) {
        botBlocks.splice(index, 1);
        renderBlocks();
        saveSession();
    }
}

// Move block up
function moveBlockUp(index) {
    if (index > 0) {
        [botBlocks[index], botBlocks[index - 1]] = [botBlocks[index - 1], botBlocks[index]];
        renderBlocks();
        saveSession();
    }
}

// Move block down
function moveBlockDown(index) {
    if (index < botBlocks.length - 1) {
        [botBlocks[index], botBlocks[index + 1]] = [botBlocks[index + 1], botBlocks[index]];
        renderBlocks();
        saveSession();
    }
}

=======
>>>>>>> main
// Generate Python code
function generateCode() {
    const botName = document.getElementById('botName').value;
    const botToken = document.getElementById('botToken').value;
    
    if (!botName || !botToken) {
        alert('Пожалуйста, заполните название и токен бота');
        return;
    }
    
    if (botBlocks.length === 0) {
        alert('Добавьте хотя бы один блок для генерации кода');
        return;
    }
    
    const code = generatePythonCode(botName, botToken, botBlocks);
    document.getElementById('generatedCode').textContent = code;
    
    const modal = new bootstrap.Modal(document.getElementById('codeModal'));
    modal.show();
}

// Generate Python code function
function generatePythonCode(botName, botToken, blocks) {
    let code = `#!/usr/bin/env python3
"""
${botName} - Telegram Bot
Создан с помощью Bot Creator Platform
"""

import telebot
from telebot import types
import logging
from datetime import datetime

# Настройка логирования
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# Инициализация бота
bot = telebot.TeleBot('${botToken}')

# Обработчики команд
`;

    blocks.forEach(block => {
        switch (block.type) {
            case 'welcome':
                code += `
@bot.message_handler(commands=['start'])
def send_welcome(message):
    """Обработчик команды /start"""
    try:
        welcome_message = """${block.config.message || 'Добро пожаловать! Я ваш новый Telegram бот.'}"""
        bot.reply_to(message, welcome_message)
        logger.info(f"User {message.from_user.id} started the bot")
    except Exception as e:
        logger.error(f"Error in send_welcome: {e}")
        bot.reply_to(message, "Произошла ошибка. Попробуйте позже.")
`;
                break;
            case 'help':
                code += `
@bot.message_handler(commands=['help'])
def send_help(message):
    """Обработчик команды /help"""
    try:
        help_text = """${block.config.commands || 'Доступные команды:\\n/start - Начать работу\\n/help - Помощь\\n/about - О боте'}"""
        bot.reply_to(message, help_text)
        logger.info(f"User {message.from_user.id} requested help")
    except Exception as e:
        logger.error(f"Error in send_help: {e}")
        bot.reply_to(message, "Произошла ошибка. Попробуйте позже.")
`;
                break;
            case 'about':
                code += `
@bot.message_handler(commands=['about'])
def send_about(message):
    """Обработчик команды /about"""
    try:
        about_text = """${block.config.description || 'Этот бот создан с помощью Bot Creator Platform.\\nВерсия: 1.0\\nДата создания: ' + datetime.now().strftime('%d.%m.%Y')}"""
        bot.reply_to(message, about_text)
        logger.info(f"User {message.from_user.id} requested about info")
    except Exception as e:
        logger.error(f"Error in send_about: {e}")
        bot.reply_to(message, "Произошла ошибка. Попробуйте позже.")
`;
                break;
            case 'message':
                code += `
@bot.message_handler(commands=['message'])
def send_message(message):
    """Отправить текстовое сообщение"""
    try:
        message_text = """${block.config.text || 'Это текстовое сообщение'}"""
        bot.reply_to(message, message_text)
        logger.info(f"User {message.from_user.id} requested message")
    except Exception as e:
        logger.error(f"Error in send_message: {e}")
        bot.reply_to(message, "Произошла ошибка. Попробуйте позже.")
`;
                break;
            case 'photo':
                code += `
@bot.message_handler(commands=['photo'])
def send_photo(message):
    """Отправить фото"""
    try:
        photo_url = """${block.config.photo_url || 'https://example.com/image.jpg'}"""
        caption = """${block.config.caption || ''}"""
        bot.send_photo(message.chat.id, photo_url, caption=caption)
        logger.info(f"User {message.from_user.id} requested photo")
    except Exception as e:
        logger.error(f"Error in send_photo: {e}")
        bot.reply_to(message, "Произошла ошибка. Попробуйте позже.")
`;
                break;
            case 'document':
                code += `
@bot.message_handler(commands=['document'])
def send_document(message):
    """Отправить документ"""
    try:
        doc_url = """${block.config.document_url || 'https://example.com/document.pdf'}"""
        caption = """${block.config.caption || ''}"""
        bot.send_document(message.chat.id, doc_url, caption=caption)
        logger.info(f"User {message.from_user.id} requested document")
    except Exception as e:
        logger.error(f"Error in send_document: {e}")
        bot.reply_to(message, "Произошла ошибка. Попробуйте позже.")
`;
                break;
            case 'inline_keyboard':
                if (block.config.text && block.config.buttons) {
                    code += `
@bot.message_handler(commands=['menu'])
def show_menu(message):
    """Показать меню с инлайн кнопками"""
    try:
        markup = types.InlineKeyboardMarkup()
        buttons_data = ${block.config.buttons}
        
        for row in buttons_data:
            markup.row(*[types.InlineKeyboardButton(text=btn, callback_data=btn.toLowerCase().replace(/\\s+/g, '_')) for btn in row])
        
        bot.reply_to(message, """${block.config.text}""", reply_markup=markup)
        logger.info(f"User {message.from_user.id} requested menu")
    except Exception as e:
        logger.error(f"Error in show_menu: {e}")
        bot.reply_to(message, "Произошла ошибка. Попробуйте позже.")

# Обработчик нажатий на инлайн кнопки
@bot.callback_query_handler(func=lambda call: True)
def handle_callback_query(call):
    """Обработчик нажатий на инлайн кнопки"""
    try:
        bot.answer_callback_query(call.id)
        button_text = call.data.replace('_', ' ').title()
        bot.send_message(call.message.chat.id, f"Вы выбрали: {button_text}")
        logger.info(f"User {call.from_user.id} clicked button: {button_text}")
    except Exception as e:
        logger.error(f"Error in handle_callback_query: {e}")
        bot.answer_callback_query(call.id, "Произошла ошибка")
`;
                }
                break;
            case 'reply_keyboard':
                if (block.config.buttons) {
                    code += `
@bot.message_handler(commands=['keyboard'])
def show_keyboard(message):
    """Показать клавиатуру"""
    try:
        markup = types.ReplyKeyboardMarkup(resize_keyboard=${block.config.resize || false}, one_time_keyboard=${block.config.one_time || false})
        buttons_data = ${block.config.buttons}
        
        for row in buttons_data:
            markup.row(*[types.KeyboardButton(btn) for btn in row])
        
        bot.reply_to(message, "Выберите опцию:", reply_markup=markup)
        logger.info(f"User {message.from_user.id} requested keyboard")
    except Exception as e:
        logger.error(f"Error in show_keyboard: {e}")
        bot.reply_to(message, "Произошла ошибка. Попробуйте позже.")

@bot.message_handler(commands=['hide_keyboard'])
def hide_keyboard(message):
    """Скрыть клавиатуру"""
    try:
        markup = types.ReplyKeyboardRemove()
        bot.reply_to(message, "Клавиатура скрыта", reply_markup=markup)
        logger.info(f"User {message.from_user.id} hid keyboard")
    except Exception as e:
        logger.error(f"Error in hide_keyboard: {e}")
        bot.reply_to(message, "Произошла ошибка. Попробуйте позже.")
`;
                }
                break;
            case 'condition':
                code += `
@bot.message_handler(func=lambda message: True)
def handle_condition(message):
    """Обработчик условного блока"""
    try:
        condition_code = """${block.config.condition}"""
        exec(condition_code)
        logger.info(f"User {message.from_user.id} triggered condition block")
    except Exception as e:
        logger.error(f"Error in handle_condition: {e}")
        bot.reply_to(message, "Произошла ошибка. Попробуйте позже.")
`;
                break;
            case 'loop':
                code += `
@bot.message_handler(func=lambda message: True)
def handle_loop(message):
    """Обработчик цикла"""
    try:
        iterations = ${block.config.iterations || 1}
        action_code = """${block.config.action || 'pass'}"""
        
        for i in range(iterations):
            exec(action_code)
            logger.info(f"User {message.from_user.id} completed loop iteration {i+1}")
        logger.info(f"User {message.from_user.id} finished loop")
    except Exception as e:
        logger.error(f"Error in handle_loop: {e}")
        bot.reply_to(message, "Произошла ошибка. Попробуйте позже.")
`;
                break;
            case 'custom':
                if (block.config.keywords && block.config.response) {
                    const keywords = block.config.keywords.split(',').map(k => k.trim());
                    code += `
@bot.message_handler(func=lambda message: any(keyword.lower() in message.text.lower() for keyword in ${JSON.stringify(keywords)}))
def custom_response(message):
    """Обработчик кастомных ключевых слов"""
    try:
        response = """${block.config.response}"""
        bot.reply_to(message, response)
        logger.info(f"User {message.from_user.id} triggered custom response")
    except Exception as e:
        logger.error(f"Error in custom_response: {e}")
        bot.reply_to(message, "Произошла ошибка. Попробуйте позже.")
`;
                }
                break;
            case 'echo':
                code += `
@bot.message_handler(func=lambda message: True)
def echo_all(message):
    """Эхо всех сообщений"""
    try:
        prefix = """${block.config.prefix || 'Эхо: '}"""
        bot.reply_to(message, prefix + message.text)
        logger.info(f"User {message.from_user.id} sent message: {message.text}")
    except Exception as e:
        logger.error(f"Error in echo_all: {e}")
        bot.reply_to(message, "Произошла ошибка. Попробуйте позже.")
`;
                break;
        }
    });
    
    code += `

# Запуск бота
if __name__ == '__main__':
    try:
        logger.info("Starting bot...")
        bot.polling(timeout=60)
    except KeyboardInterrupt:
        logger.info("Bot stopped by user")
    except Exception as e:
        logger.error(f"Bot error: {e}")
    finally:
        logger.info("Bot stopped")
`;
    
    return code;
}

// Save bot
function saveBot() {
    const botName = document.getElementById('botName').value;
    const botToken = document.getElementById('botToken').value;
    const botDescription = document.getElementById('botDescription').value;
    
    if (!botName || !botToken) {
        alert('Пожалуйста, заполните название и токен бота');
        return;
    }
    
    if (botBlocks.length === 0) {
        alert('Добавьте хотя бы один блок для сохранения бота');
        return;
    }
    
    const botData = {
        name: botName,
        token: botToken,
        description: botDescription,
        config: botBlocks,
        python_code: generatePythonCode(botName, botToken, botBlocks)
    };
    
    // Save to server
<<<<<<< HEAD
    fetch('/api/create-bot', {
=======
    fetch('/api/save-bot', {
>>>>>>> main
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify(botData)
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            alert('Бот успешно сохранен!');
            clearSession();
        } else {
<<<<<<< HEAD
            alert('Ошибка при сохранении: ' + data.error);
            alert('Ошибка при сохранении: ' + data.error);
        }
    })
    .catch(error => {
        console.error('Error:', error);
        alert('Произошла ошибка при сохранении бота');
    });
}

// Copy code to clipboard
function copyCode() {
    const codeElement = document.getElementById('generatedCode');
    const textArea = document.createElement('textarea');
    textArea.value = codeElement.textContent;
    document.body.appendChild(textArea);
    textArea.select();
    document.execCommand('copy');
    document.body.removeChild(textArea);
    alert('Код скопирован в буфер обмена!');
}

// Download code as file
function downloadCode() {
    const codeElement = document.getElementById('generatedCode');
    const blob = new Blob([codeElement.textContent], { type: 'text/plain' });
    const url = window.URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'bot.py';
    a.click();
    window.URL.revokeObjectURL(url);
}

// Clear session
function clearSession() {
    if (confirm('Вы уверены, что хотите очистить все данные?')) {
        botBlocks = [];
        blockCounter = 0;
        document.getElementById('botForm').reset();
        renderBlocks();
        saveSession();
    }
}

// Save session to localStorage
function saveSession() {
    const sessionData = {
        botBlocks: botBlocks,
        blockCounter: blockCounter,
        formData: {
            botName: document.getElementById('botName').value,
            botToken: document.getElementById('botToken').value,
            botDescription: document.getElementById('botDescription').value
        }
    };
    localStorage.setItem('botCreatorSession', JSON.stringify(sessionData));
}

// Load session from localStorage
function loadSession() {
    const sessionData = localStorage.getItem('botCreatorSession');
    if (sessionData) {
        try {
            const data = JSON.parse(sessionData);
            botBlocks = data.botBlocks || [];
            blockCounter = data.blockCounter || 0;
            
            if (data.formData) {
                document.getElementById('botName').value = data.formData.botName || '';
                document.getElementById('botToken').value = data.formData.botToken || '';
                document.getElementById('botDescription').value = data.formData.botDescription || '';
            }
        } catch (e) {
            console.error('Error loading session:', e);
        }
    }
}

// Update block configuration
function updateBlockConfig(index, key, value) {
    if (botBlocks[index]) {
        if (!botBlocks[index].config) {
            botBlocks[index].config = {};
        }
        botBlocks[index].config[key] = value;
        saveSession();
    }
}

// Validate JSON input
function validateJSON(textarea, blockIndex, fieldName) {
    const blockElement = textarea.closest('.block-config');
    const feedback = blockElement.querySelector('.json-validation-feedback');
    const jsonString = textarea.value.trim();
    
    if (!jsonString) {
        feedback.style.display = 'none';
        textarea.classList.remove('error', 'valid');
        return;
    }
    
    let isValid = true;
    let errorMessage = '';

    try {
        const parsed = JSON.parse(jsonString);
        
        // Дополнительная валидация для кнопок
        if (fieldName === 'buttons') {
            if (!Array.isArray(parsed)) {
                throw new Error('Должен быть массив');
            }
            
            for (let i = 0; i < parsed.length; i++) {
                if (!Array.isArray(parsed[i])) {
                    throw new Error(`Элемент ${i} должен быть массивом`);
                }
                
                for (let j = 0; j < parsed[i].length; j++) {
                    if (typeof parsed[i][j] !== 'string') {
                        throw new Error(`Кнопка [${i}][${j}] должна быть строкой`);
                    }
                    
                    if (parsed[i][j].trim() === '') {
                        throw new Error(`Кнопка [${i}][${j}] не может быть пустой`);
                    }
                }
            }
        }
        
    } catch (e) {
        isValid = false;
        errorMessage = `Неверный формат JSON: ${e.message}`;
    }

    if (isValid) {
        feedback.textContent = '✅ JSON валиден!';
        feedback.style.display = 'block';
        feedback.className = 'json-validation-feedback text-success';
        textarea.classList.remove('error');
        textarea.classList.add('valid');
    } else {
        feedback.textContent = `❌ ${errorMessage}`;
        feedback.style.display = 'block';
        feedback.className = 'json-validation-feedback text-danger';
        textarea.classList.remove('valid');
        textarea.classList.add('error');
    }
}

// Preview buttons for inline_keyboard and reply_keyboard
function previewButtons(textarea, blockType) {
    const previewDiv = textarea.closest('.block-config').querySelector('.button-preview');
    const jsonString = textarea.value.trim();

    if (!jsonString) {
        previewDiv.style.display = 'none';
        return;
    }

    try {
        const parsed = JSON.parse(jsonString);
        let html = '<h6>Предварительный просмотр кнопок:</h6>';

        if (blockType === 'inline_keyboard') {
            if (Array.isArray(parsed) && parsed.length > 0) {
                html += '<div class="btn-group-vertical">';
                parsed.forEach(row => {
                    html += '<div class="btn-group">';
                    row.forEach(btn => {
                        html += `<button class="btn btn-sm btn-outline-primary me-1 mb-1">${btn}</button>`;
                    });
                    html += '</div>';
                });
                html += '</div>';
            } else {
                html += '<p class="text-muted">Кнопки не заданы или неверный формат.</p>';
            }
        } else if (blockType === 'reply_keyboard') {
            if (Array.isArray(parsed) && parsed.length > 0) {
                html += '<div class="btn-group-vertical">';
                parsed.forEach(row => {
                    html += '<div class="btn-group">';
                    row.forEach(btn => {
                        html += `<button class="btn btn-sm btn-outline-secondary me-1 mb-1">${btn}</button>`;
                    });
                    html += '</div>';
                });
                html += '</div>';
            } else {
                html += '<p class="text-muted">Кнопки не заданы или неверный формат.</p>';
            }
        }
        previewDiv.innerHTML = html;
        previewDiv.style.display = 'block';
    } catch (e) {
        previewDiv.innerHTML = `<p class="text-danger">Ошибка парсинга JSON: ${e.message}</p>`;
        previewDiv.style.display = 'block';
    }
}

// Drag and drop functionality
function handleDragStart(e) {
    e.dataTransfer.setData('text/plain', e.target.dataset.blockType);
    e.dataTransfer.effectAllowed = 'copy';
}

function handleDragOver(e) {
    e.preventDefault();
    e.dataTransfer.dropEffect = 'copy';
}

function handleDragEnter(e) {
    e.preventDefault();
    const dropZone = document.getElementById('botBlocks');
    dropZone.classList.add('drag-over');
}

function handleDragLeave(e) {
    e.preventDefault();
    const dropZone = document.getElementById('botBlocks');
    dropZone.classList.remove('drag-over');
}

function handleDrop(e) {
    e.preventDefault();
    const dropZone = document.getElementById('botBlocks');
    dropZone.classList.remove('drag-over');
    
    const blockType = e.dataTransfer.getData('text/plain');
    if (blockType) {
        addBlockByType(blockType);
    }
}


// Auto-save on form changes
document.getElementById('botForm').addEventListener('input', saveSession);

// Initialize button previews when page loads
document.addEventListener('DOMContentLoaded', function() {
    setTimeout(initializeButtonPreviews, 1000);
});
</script>
{% endblock %}